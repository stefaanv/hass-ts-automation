import * as WebSocket from 'ws'
import { EventInfo, IncomingMessage, OutgoingMessage } from './hass/hass-message.types.js'
import { IntegrationBase } from '@src/architecture/integration.base.js'
import { ConfigService } from '@nestjs/config'
import { Logger } from '@nestjs/common'
import { utcToLocal } from '@src/utilities'
import { appendFile, readFile } from 'fs/promises'
import {
  LightOnoffState,
  LightOnoffStateUpdate,
  OpenCloseStateUpdate,
  PresenceStateUpdate,
} from '@src/architecture/event-models/enum-state-update.model'
import { first } from '@bruyland/utilities'

const logFilePath = 'C:\\Users\\stefa\\Documents\\projecten\\hass-ts-automation\\hass-driver.log'

export default class HassIntegration extends IntegrationBase {
  public readonly name = 'Home Assistant'
  public readonly version = '0.0.1'
  public readonly id = 'hass'

  private cmdIdCounter = 1
  private ws: WebSocket
  private readonly hassWsUrl: string
  private readonly accessToken: string
  private writtenToLog: string[] = []
  private readonly sendAllMessages: boolean

  constructor(_driverFileName: string, localConfig: any, globalConfig: ConfigService) {
    // general setup
    super(localConfig, globalConfig)
    this._log = new Logger(this.name)

    // get the configuration
    this.hassWsUrl = this.getConfig('baseUrl', '')
    this.accessToken = this.getConfig('authToken', '')
    this.debug = true
    this.sendAllMessages = this.getConfig('sendAllMessages', false)
  }

  private setWsListeners() {
    this.ws.on('error', console.error)
    this.ws.on('message', (buf: Buffer) => {
      const msg = buf.toString()
      if (msg.includes('result') && msg.includes('"success": false')) console.log(msg)
      this.processIncomingMessage(JSON.parse(msg))
    })
  }

  async start() {
    this._log.debug!(`Connecting to websocket ${this.hassWsUrl}`)
    this.ws = new WebSocket(this.hassWsUrl)
    this.setWsListeners()
    // start listening to `light` commands
    IntegrationBase.eventEmitter.on('command.light', (data: any) => this.changeLight(data))
    return true
  }

  async stop() {}

  entityFrom(nativeMessage: IncomingMessage): string | undefined {
    if (nativeMessage.type.startsWith('auth')) return undefined
    if (nativeMessage.type === 'event') return nativeMessage.event.data.entity_id
    if (nativeMessage.type === 'result') return undefined
    console.error(`Add to entityFrom(): ${JSON.stringify(nativeMessage)}`)
    return undefined
  }

  changeLight(data: { entity: string; onOff: LightOnoffState }) {
    const entityDef = this.commands.find(c => c.type === 'light' && c.entity === data.entity)
    const msg = {
      id: this.cmdIdCounter++,
      type: 'call_service',
      domain: 'light',
      service: `turn_${data.onOff}`,
      // Optional
      // "service_data": {
      //   "color_name": "beige",
      //   "brightness": "101"
      // }
      // Optional
      target: {
        entity_id: entityDef?.outEntity,
      },
    }
    this.ws.send(JSON.stringify(msg))
  }

  private processIncomingMessage(data: IncomingMessage) {
    const entity = this.entityFrom(data)
    switch (data.type) {
      case 'auth_required':
        this.logDebug(`Connected to HASS ${data.ha_version ?? ''}, attempting logon`)
        this.sendToHass({ type: 'auth', access_token: this.accessToken })
        break
      case 'auth_ok':
        this.logDebug(`Logon succeeded`)
        this.sendToHass({ id: this.cmdIdCounter++, type: 'subscribe_events', event_type: 'state_changed' })
        this.startPromise(true)
        break
      case 'auth_invalid':
        this._logger.error(`Logon Failed - ${data.message}`)
        this.startPromise(false)
        break
      default:
        if (entity && !this.writtenToLog.includes(entity)) {
          appendFile(logFilePath, entity + ';' + JSON.stringify(data) + '\r\n')
          this.writtenToLog.push(entity)
        }
        if (entity) {
          if (!entity) return // don't process if entity returns undefined
          const transformed = this.transformKnownMessageContent(data)
          if (!transformed) {
            if (this.sendAllMessages) this.sendMessage(entity, { ...data, timestamp: new Date() })
          } else this.sendMessage(transformed.entity, transformed.content)
        }
        break
    }
  }

  //TODO !! test entity blocking/selecting before message transformation
  transformKnownMessageContent(natMsg: any): { entity: string; content: IMessageContent } | undefined {
    if (natMsg.type === 'event') {
      const timestamp = utcToLocal(natMsg.event?.data?.new_state.last_updated)
      const entity = (natMsg.event?.data?.entity_id as string) ?? '-=unknown=-'
      const entityTypeTuple = this.entityTypes.find(et => et.entity === entity)
      if (!entityTypeTuple) return undefined
      let content: KnownContent | undefined = undefined
      // extract common states
      const oldOnoffState = natMsg.event?.data?.old_state.state ?? 'off'
      const newOnoffState = natMsg.event?.data?.new_state.state ?? 'off'

      switch (entityTypeTuple.type) {
        case 'motionDetectors':
          content = new PresenceStateUpdate(
            natMsg.event?.data?.new_state.state === 'on' ? 'present' : 'absent',
            timestamp,
          )
          return { entity: entityTypeTuple.outEntity, content }
        case 'doorContacts':
          content = new OpenCloseStateUpdate(newOnoffState == 'on' ? 'open' : 'closed', timestamp)
          return { entity: entityTypeTuple.outEntity, content }
        case 'lights':
          const oldDimState = natMsg.event?.data?.old_state.attributes.brightness ?? 0
          const newDimState = natMsg.event?.data?.new_state.attributes.brightness ?? 0
          if (oldOnoffState !== newOnoffState) {
            content = new LightOnoffStateUpdate(newOnoffState == 'on' ? 'on' : 'off', timestamp)
          }
          if (!content && oldDimState !== newDimState) {
            content = new LightDimStateUpdate(newDimState)
          }
          return !content ? undefined : { entity: entityTypeTuple.outEntity, content }
      }

      // default valueUpdate
      const event: EventInfo = natMsg.event
      const newState = event.data?.new_state.state
      const numberState = isNaN(parseFloat(newState)) ? undefined : parseFloat(newState)
      const unit = event.data.new_state.attributes.unit_of_measurement ?? ''
      return { entity, content: new ValueStateUpdate(newState, unit, numberState) }
    }
    return undefined
  }

  private sendToHass(msg: OutgoingMessage) {
    this.ws.send(JSON.stringify(msg))
  }
}
